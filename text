1)  set ns [new Simulator]
set nf [open tcp1.nam w]
$ns namtrace-all $nf
set nt [open tcp1.tr w]
$ns trace-all $nt
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]
$n0 color blue
$n1 color red
$n2 color green
$ns color 0 purple
$ns duplex-link $n0 $n1 1Mb 100ms DropTail
$ns duplex-link $n1 $n2 600Kb 100ms DropTail
$ns queue-limit $n1 $n2 5
$ns duplex-link-op $n0 $n1 orient right
$ns duplex-link-op $n1 $n2 orient right
$ns at 0.0 "$n0 label Client1"
$ns at 0.0 "$n1 label Router1"
$ns at 0.0 "$n2 label Endserver1"
$n2 shape hexagon
$n1 shape square
set udp0 [new Agent/UDP]
$ns attach-agent $n0 $udp0
set cbr0 [new Application/Traffic/CBR]
$cbr0 set packetSize_ 800
$cbr0 set interval_ 0.008
$cbr0 attach-agent $udp0
set sink [new Agent/Null]
$ns attach-agent $n2 $sink
$ns connect $udp0 $sink
proc finish {} {
global ns nf nt
$ns flush-trace
close $nf
close $nt
puts "running nam...."
exec nam tcp1.nam &
exit 0
}
$ns at 0.1 "$cbr0 start"
$ns at 3.0 "$cbr0 stop"
$ns at 3.5 "finish"
$ns run

2)  set ns [new Simulator]
set nf [open lab2.nam w]
$ns namtrace-all $nf
set nd [open lab2.tr w]
$ns trace-all $nd
proc finish {} {
global ns nf nd
$ns flush-trace
close $nf
close $nd
exec nam lab2.nam &
exit 0
}
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]
set n4 [$ns node]
set n5 [$ns node]
set n6 [$ns node]
$ns duplex-link $n1 $n0 1Mb 10ms DropTail
$ns duplex-link $n2 $n0 1Mb 10ms DropTail
$ns duplex-link $n3 $n0 1Mb 10ms DropTail
$ns duplex-link $n4 $n0 1Mb 10ms DropTail
$ns duplex-link $n5 $n0 1Mb 10ms DropTail
$ns duplex-link $n6 $n0 1Mb 10ms DropTail
Agent/Ping instproc recv {from rtt} {
$self instvar node_
puts "node [$node_ id] recieved ping answer from \
$from with round-trip-time $rtt ms."
}
set p1 [new Agent/Ping]
set p2 [new Agent/Ping]
set p3 [new Agent/Ping]
set p4 [new Agent/Ping]
set p5 [new Agent/Ping]
set p6 [new Agent/Ping]
$ns attach-agent $n1 $p1
$ns attach-agent $n2 $p2
$ns attach-agent $n3 $p3
$ns attach-agent $n4 $p4
$ns attach-agent $n5 $p5
$ns attach-agent $n6 $p6
$ns queue-limit $n0 $n4 3
$ns queue-limit $n0 $n5 2
$ns queue-limit $n0 $n6 2
$ns connect $p1 $p4
$ns connect $p2 $p5
$ns connect $p3 $p6
$ns at 0.2 "$p1 send"
$ns at 0.4 "$p2 send"
$ns at 0.6 "$p3 send"
$ns at 1.0 "$p4 send"
$ns at 1.2 "$p5 send"
$ns at 1.4 "$p6 send"
$ns at 2.0 "finish"
$ns run


3)  set ns [new Simulator]
 set nf [open lab3.nam w]
 $ns namtrace-all $nf
 set nd [open lab3.tr w]
 $ns trace-all $nd
 $ns color 1 Blue
 $ns color 2 Red
 proc finish { } {
 global ns nf nd
 $ns flush-trace
 close $nf
 close $nd
 exec nam lab3.nam &
 exit 0
 }
 set n0 [$ns node]
 set n1 [$ns node]
 set n2 [$ns node]
 set n3 [$ns node]
 set n4 [$ns node]
 set n5 [$ns node]
 set n6 [$ns node]
 set n7 [$ns node]
 set n8 [$ns node]
 $n7 shape box
 $n7 color Blue
 $n8 shape hexagon
 $n8 color Red
 $ns duplex-link $n1 $n0 2Mb 10ms DropTail
 $ns duplex-link $n2 $n0 2Mb 10ms DropTail
 $ns duplex-link $n0 $n3 1Mb 20ms DropTail
 $ns make-lan "$n3 $n4 $n5 $n6 $n7 $n8" 512Kb 40ms LL
 Queue/DropTail Mac/802_3;
 $ns duplex-link-op $n1 $n0 orient right-down
 $ns duplex-link-op $n2 $n0 orient right-up
 $ns duplex-link-op $n0 $n3 orient right
 $ns queue-limit $n0 $n3 20
 set tcp1 [new Agent/TCP/Vegas]
 $ns attach-agent $n1 $tcp1
 set sink1 [new Agent/TCPSink]
 $ns attach-agent $n7 $sink1
 $ns connect $tcp1 $sink1
 $tcp1 set class_ 1
 $tcp1 set packetsize_ 55
 set ftp1 [new Application/FTP]
 $ftp1 attach-agent $tcp1
 set ftp2 [new Application/FTP]
 $ftp2 attach-agent $tcp1
 set tfile [open cwnd.tr w]
 $tcp1 attach $tfile
 $tcp1 trace cwnd_
 $ns at 0.5 "$ftp1 start"
 $ns at 1.0 "$ftp2 start"
 $ns at 5.0 "$ftp2 stop"
 $ns at 5.0 "$ftp1 stop"
 $ns at 5.5 "finish"
 $ns run


4)  set ns [new Simulator]
set val(chan) Channel/WirelessChannel;
set val(prop) Propagation/TwoRayGround;
set val(netif) Phy/WirelessPhy;
set val(mac) Mac/802_11;
set val(ifq) Queue/DropTail/PriQueue;
set val(ll) LL;
set val(ant) Antenna/OmniAntenna;
set val(ifqlen) 50;
set val(nn) 2;
set val(rp) DSDV;
set val(y) 1000.0;
set tf [open lab4.tr w]
$ns trace-all $tf
set topo [new Topography]
$topo load_flatgrid 1000 1000
set nf [open lab4.nam w]
$ns namtrace-all-wireless $nf 1000 1000
$ns node-config -adhocRouting $val(rp) \
-llType $val(ll) \
-macType $val(mac) \
-ifqType $val(ifq) \
-ifqLen $val(ifqlen) \
-antType $val(ant) \
-propType $val(prop) \
-phyType $val(netif) \
-channelType $val(chan) \
-topoInstance $topo \
-agentTrace ON \
-routerTrace ON \
-macTrace ON
create-god $val(nn)
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]
$n0 label "tcp0"
$n1 label "sink1/tcp1"
$n2 label "sink2"
$n0 set X_ 250
$n0 set Y_ 250
$n0 set Z_ 0
$n1 set X_ 300
$n1 set Y_ 300
$n1 set Z_ 0
$n2 set X_ 600
$n2 set Y_ 600
$n2 set Z_ 0
$ns at 0.1 "$n0 setdest 250 250 15"
$ns at 0.1 "$n1 setdest 300 300 25"
$ns at 0.1 "$n2 setdest 600 600 25"
set tcp0 [new Agent/TCP]
$ns attach-agent $n0 $tcp0
set ftp0 [new Application/FTP]
$ftp0 attach-agent $tcp0
set sink1 [new Agent/TCPSink]
$ns attach-agent $n1 $sink1
$ns connect $tcp0 $sink1
set tcp1 [new Agent/TCP]
$ns attach-agent $n1 $tcp1
set ftp1 [new Application/FTP]
$ftp1 attach-agent $tcp1
set sink2 [new Agent/TCPSink]
$ns attach-agent $n2 $sink2
$ns connect $tcp1 $sink2
$ns at 5 "$ftp0 start"
$ns at 5 "$ftp1 start"
$ns at 100 "$n1 setdest 550 550 15"
$ns at 190 "$n1 setdest 70 70 15"
proc finish {} {
global ns nf tf
$ns flush-trace
exec nam lab4.nam &
close $tf
exit 0
}
$ns at 250 "finish"
$ns run


5)set stop 100
set type gsm
set minth 30
set maxth 0
set adaptive 1
set flows 0
set window 30
set opt(wrap) 100
set opt(srcTrace) is
set opt(dstTrace) bs2
set bwDL(gsm) 9600
set propDL(gsm) .500
set ns [new Simulator]
set tf [open gsm.tr w]
$ns trace-all $tf
set nodes(is) [$ns node]
set nodes(ms) [$ns node]
set nodes(bs1) [$ns node]
set nodes(bs2) [$ns node]
set nodes(lp) [$ns node]
proc cell_topo {} {
global ns nodes
$ns duplex-link $nodes(lp) $nodes(bs1) 3Mbps 10ms DropTail
$ns duplex-link $nodes(bs1) $nodes(ms) 1 1 RED
$ns duplex-link $nodes(ms) $nodes(bs2) 1 1 RED
$ns duplex-link $nodes(bs2) $nodes(is) 3Mbps 10ms DropTail
puts "GSM Cell Topology"
}
proc set_link_params {t} {
global ns nodes bwDL propDL
$ns bandwidth $nodes(bs1) $nodes(ms) $bwDL($t) duplex
$ns bandwidth $nodes(bs2) $nodes(ms) $bwDL($t) duplex
$ns delay $nodes(bs1) $nodes(ms) $propDL($t) duplex
$ns delay $nodes(bs2) $nodes(ms) $propDL($t) duplex
$ns queue-limit $nodes(bs1) $nodes(ms) 10
$ns queue-limit $nodes(bs2) $nodes(ms) 10
}
Queue/RED set adaptive_ $adaptive
Queue/RED set thresh_ $minth
Queue/RED set maxthresh_ $maxth
Agent/TCP set window_ $window
source web.tcl
switch $type {
gsm -
cdma {cell_topo}
}
set_link_params $type
$ns insert-delayer $nodes(ms) $nodes(bs1) [new Delayer]
$ns insert-delayer $nodes(ms) $nodes(bs2) [new Delayer]
if {$flows ==0} {
set tcp1 [$ns create-connection TCP/Sack1 $nodes(is) TCPSink/Sack1 $nodes(lp) 0]
set ftp1 [[set tcp1] attach-app FTP]
$ns at 0.8 "[set ftp1] start"
}
proc stop {} {
global nodes opt tf
set wrap $opt(wrap)
set sid [$nodes($opt(srcTrace)) id]
set did [$nodes($opt(dstTrace)) id]
set a "p5.tr"
set GETRC "../../../bin/getrc"
set RAW2XG "../../../bin/raw2xg"
exec $GETRC -s $sid -d $did -f 0 gsm.tr | \
$RAW2XG -s 0.01 -m $wrap -r > plot.xgr
exec $GETRC -s $did -d $sid -f 0 gsm.tr | \
$RAW2XG -a -s 0.01 -m $wrap >> plot.xgr
exec xgraph -x "time" -y "packets" plot.xgr &
exit 0
}
$ns at $stop "stop"
$ns run


6)set stop 100
set type cdma
set minth 30
set maxth 0
set adaptive 1
set flows 0
set window 30
set opt(wrap) 100
set opt(srcTrace) is
set opt(dstTrace) bs2
set bwDL(cdma) 384000
set propDL(cdma) .150
set ns [new Simulator]
set tf [open p6.tr w]
$ns trace-all $tf
set nodes(is) [$ns node]
set nodes(ms) [$ns node]
set nodes(bs1) [$ns node]
set nodes(bs2) [$ns node]
set nodes(lp) [$ns node]
proc cell_topo {} {
global ns nodes
$ns duplex-link $nodes(lp) $nodes(bs1) 3Mbps 10ms DropTail
$ns duplex-link $nodes(bs1) $nodes(ms) 1 1 RED
$ns duplex-link $nodes(ms) $nodes(bs2) 1 1 RED
$ns duplex-link $nodes(bs2) $nodes(is) 3Mbps 10ms DropTail
puts "cdma Cell Topolgy"
}
proc set_link_para {t} {
global ns nodes bwDL propDL
$ns bandwidth $nodes(bs1) $nodes(ms) $bwDL($t) duplex
$ns bandwidth $nodes(bs2) $nodes(ms) $bwDL($t) duplex
$ns delay $nodes(bs1) $nodes(ms) $propDL($t) duplex
$ns delay $nodes(bs2) $nodes(ms) $propDL($t) duplex
$ns queue-limit $nodes(bs1) $nodes(ms) 20
$ns queue-limit $nodes(bs2) $nodes(ms) 20
}
Queue/RED set adaptive_ $adaptive
Queue/RED set thresh_ $minth
Queue/RED set maxthresh_ $maxth
Agent/TCP set window_ $window
source web.tcl
switch $type {
cdma {cell_topo}
}
set_link_para $type
$ns insert-delayer $nodes(ms) $nodes(bs1) [new Delayer]
$ns insert-delayer $nodes(ms) $nodes(bs2) [new Delayer]
if {$flows ==0} {
set tcp1 [$ns create-connection TCP/Sack1 $nodes(is) TCPSink/Sack1 $nodes(lp) 0]
set ftp1 [[set tcp1] attach-app FTP]
$ns at 0.8 "[set ftp1] start"
}
proc stop {} {
global nodes opt tf
set wrap $opt(wrap)
set sid [$nodes($opt(srcTrace)) id]
set did [$nodes($opt(dstTrace)) id]
set a "p6.tr"
set GETRC "../../../bin/getrc"
set RAW2XG "../../../bin/raw2xg"
exec $GETRC -s $sid -d $did -f 0 p6.tr | \
$RAW2XG -s 0.01 -m $wrap -r > plot.xgr
exec $GETRC -s $did -d $sid -f 0 p6.tr | \
$RAW2XG -a -s 0.01 -m $wrap >> p6.xgr
exec xgraph -x time -y packets plot.xgr &
exit 0
}
$ns at $stop "stop"
$ns run


------Part B------

7)  import java.util.*;
public class Crc {
public static int n;
public static void main(String[] args) {
Scanner in= new Scanner (System.in);
Crc ob=new Crc();
String code,copy,rec,zero="0000000000000000";
System.out.println("Enter message");
code=in.nextLine();
n=code.length();
copy=code;
code+=zero;
code=ob.divide(code);
System.out.println("Message="+copy);
copy=copy.substring(0,n)+code.substring(n);
System.out.println("Crc=");
System.out.println(code.substring(n));
System.out.println("transmitted frame is"+copy);
System.out.println("Enter recieved data");
rec=in.nextLine();
if(zero.equals(ob.divide(rec).substring(n)))
System.out.println("correct bits received");
else
System.out.println("Received frame contain one or more errors");
in.close();
}
public String divide(String s)
{
int i,j;
char x;
String div="10001000000100001";
for(i=0;i<n;i++)
{
x=s.charAt(i);
for(j=0;j<17;j++)
{
if(x=='1')
{
if(s.charAt(i+j)!=div.charAt(j))
s=s.substring(0,i+j)+"1"+s.substring(i+j+1);
else
s=s.substring(0,i+j)+"0"+s.substring(i+j+1);
}
}
}
return s;
}
}


8)    import java.util.*; 
public class Belmanford 
 { 
 private int D[]; 
 private int n; 
 public static final int max_value=999; 
 public Belmanford(int n) 
 { 
 this.n=n; 
 D=new int[n+1]; 
 } 
 public void shortest(int s,int a[][]) 
 { 
 for(int i=1;i<=n;i++) 
 { 
 D[i]=max_value; 
 } 
 D[s]=0; 
 for(int k=1;k<=n-1;k++) 
 { 
 for(int i=1;i<=n;i++) 
 { 
 for(int j=1;j<=n;j++) 
 { 
 if(a[i][j]!=max_value) 
 { 
 if(D[j]>D[i]+a[i][j]) 
 D[j]=D[i]+a[i][j]; 
 } 
 } 
 } 
 } 
 for (int i=1;i<=n;i++) 
 { 
 for (int j=1;j<=n;j++) 
 { 
 if(a[i][j]!=max_value) 
 { 
 if(D[j]>D[i]+a[i][j]) 
 { 
 System.out.println("the graph contains -ve edge cycle"); 
 return; 
 } 
 } 
 } 
 } 
 for (int i=1;i<=n;i++) 
 { 
 System.out.println("distance of source"+s+"to"+i+"is"+D[i]); 
 } 
 } 
 public static void main(String[] args) 
{ 
 int n=0,s; 
 Scanner sc=new Scanner(System.in); 
 System.out.println("enter the no.of values"); 
 n=sc.nextInt(); 
 int a[][]=new int [n+1][n+1]; 
 System.out.println("enter the weighted matrix:"); 
 for (int i=1;i<=n;i++) 
 { 
 for (int j=1;j<=n;j++) 
 { 
 a[i][j]=sc.nextInt(); 
 if(i==j) 
 { 
 a[i][j]=0; 
 continue; 
 } 
 if(a[i][j]==0) 
 a[i][j]=max_value; 
 } 
 } 
 System.out.println("enter the source vertex:"); 
 s=sc.nextInt(); 
 Belmanford b=new Belmanford(n); 
 b.shortest(s,a); 
 sc.close(); 
 } 
 }


9)  import java.net.*;
import java.io.*;
public class TCPClient
{
public static void main(String args[]) throws Exception {
Socket sock=new Socket("127.0.0.1",4000);
System.out.println("Enter the filename");
BufferedReader keyRead=new BufferedReader(new InputStreamReader(System.in));
String fname=keyRead.readLine();
OutputStream ostream=sock.getOutputStream();
PrintWriter pwrite=new PrintWriter(ostream,true);
pwrite.println(fname);
InputStream istream=sock.getInputStream();
BufferedReader socketRead=new BufferedReader(new InputStreamReader(istream));
String str;
while((str=socketRead.readLine())!=null)
{
System.out.println(str);
}
pwrite.close();
socketRead.close();
keyRead.close();
}
}


import java.net.*;
import java.io.*;
public class TCPServer
{
public static void main(String args[]) throws Exception {
ServerSocket sersock=new ServerSocket(4000);
System.out.println("Server ready for Connection");
Socket sock=sersock.accept();
System.out.println("Connection is Successful and waiting for chatting");
InputStream istream=sock.getInputStream();
BufferedReader fileRead=new BufferedReader(new InputStreamReader(istream));
String fname=fileRead.readLine();
BufferedReader contentRead=new BufferedReader(new FileReader(fname));
OutputStream ostream=sock.getOutputStream();
PrintWriter pwrite=new PrintWriter(ostream,true);
String str;
while((str=contentRead.readLine())!=null)
{
pwrite.println(str);
}
sock.close();
sersock.close();
pwrite.close();
fileRead.close();
contentRead.close();
}
}



10)   import java.io.*; 
import java.net.*; 
public class UDPServer 
{ 
 public static void main(String[] args) 
 { 
DatagramSocket skt=null; 
try 
{ 
System.out.println("server is started"); 
skt=new DatagramSocket(6788); 
byte[] buffer = new byte[1000]; 
while(true) 
{ 
DatagramPacket request = new DatagramPacket(buffer,buffer.length); 
skt.receive(request); 
String[] message = (new String(request.getData())).split(" "); 
byte[] sendMsg= (message[1].toUpperCase()+ " from server to client").getBytes(); 
DatagramPacket reply = new 
DatagramPacket(sendMsg,sendMsg.length,request.getAddress(),request.getPort()); 
skt.send(reply); 
} 
} 
catch(Exception ex) 
{ 
System.out.println(ex.getMessage()); 
} 
} 
} 



import java.io.*; 
import java.net.*; 
public class UDPClient 
{ 
 public static void main(String[] args) 
{ 
DatagramSocket skt; 
try 
{ 
skt=new DatagramSocket(); 
String msg= "atme college "; 
byte[] b = msg.getBytes(); 
InetAddress host=InetAddress.getByName("127.0.0.1"); 
int serverSocket=6788; 
DatagramPacket request =new DatagramPacket (b,b.length,host,serverSocket); 
skt.send(request); 
byte[] buffer =new byte[1000]; 
DatagramPacket reply= new DatagramPacket(buffer,buffer.length); 
skt.receive(reply); 
System.out.println("client received:" +new String(reply.getData()));
skt.close(); 
} 
catch(Exception ex) 
{ 
 System.out.println(ex.getMessage()); 
} 
} 
}



11)import java.util.*;
import java.io.*;
public class rsa
{
static int gcd(int m,int n)
{
while(n!=0)
{
int r=m%n;
m=n;
n=r;
}
return m;
}
public static void main(String args[])
{
int p=0,q=0,n=0,e=0,d=0,phi=0;
int nummes[]=new int[100];
int encrypted[]=new int[100];
int decrypted[]=new int[100];
int i=0,j=0,nofelem=0;
Scanner sc=new Scanner(System.in);
String message;
System.out.println("Enter the Message to be encrypted:");
message=sc.nextLine();
System.out.println("Enter value of p and q\n");
p=sc.nextInt();
q=sc.nextInt();
n=p*q;
phi=(p-1)*(q-1);
for(i=2;i<phi;i++)
if(gcd(i,phi)==1)
break;
e=i;
for(i=2;i<phi;i++)
if((e*i-1)%phi==0)
break;
d=i;
for(i=0;i<message.length();i++)
{
char c=message.charAt(i);
int a=(int)c;
nummes[i]=c-96;
}
nofelem=message.length();
for(i=0;i<nofelem;i++)
{
encrypted[i]=1;
for(j=0;j<e;j++)
encrypted[i]=(encrypted[i]*nummes[i])%n;
}
System.out.println("\nEncrypted message\n");
for(i=0;i<nofelem;i++)
{
System.out.println(encrypted[i]);
//System.out.println((char) (encrypted[i]+96));
}
for(i=0;i<nofelem;i++)
{
decrypted[i]=1;
for(j=0;j<d;j++)
decrypted[i]=(decrypted[i]*encrypted[i])%n;
}
System.out.println("\n Decrypted messages\n");
for(i=0;i<nofelem;i++)
System.out.print((char) (decrypted[i]+96));
return;
}
}


12) import java.util.Scanner;
public class Leaky {
public static void main(String args[]){
Scanner sc=new Scanner(System.in);
int bucket=0,op_rate,i,n,bsize;
System.out.println("enter number of packets");
n=sc.nextInt();
int pkt[]=new int[n];
System.out.println("enter the output rate of the bucket");
op_rate=sc.nextInt();
System.out.println("enter the bucket size");
bsize=sc.nextInt();
System.out.println("enter the arriving packets(size)");
for(i=0;i<n;i++)
pkt[i]=sc.nextInt();
System.out.println("\nsec\tpsize\tbucket\taccept/reject\tpkt_send");
System.out.println("-------------------------------------------------------");
for(i=0;i<n;i++)
{
System.out.print(i+1+"\t"+pkt[i]+"\t");
if(bucket+pkt[i]<=bsize)
{
bucket+=pkt[i];
System.out.println(bucket +"\t\taccept\t\t"+ min(bucket,op_rate)+"\n");
bucket=sub(bucket,op_rate);
}
else
{
System.out.println(bucket + "\t\treject\t" + (bucket+pkt[i]-bsize) + "\t" + 
min(bsize,op_rate) +"\n");
bucket=bsize;
bucket=sub(bucket,op_rate);
}
}
while(bucket!=0)
{
System.out.print(++i +"\\t"+bucket + "\t\taccept\t\t" + min(bucket,op_rate)+"\n");
bucket=sub(bucket,op_rate);
}
sc.close();
}
static int min(int a,int b)
{
return(a<b)?a:b;
}
static int sub(int a,int b)
{
return(a-b)>0?(a-b):0;
}
}
